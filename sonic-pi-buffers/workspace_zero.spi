require 'treetop'
Treetop.load 'PATH_TO/grammar/forge_grammar.tt'

parser = ForgeGrammarParser.new
empty_anvil = { :name => :silence, :mods => [] , :release => 1 }
map = { "k" => :drum_heavy_kick,
        "s" => :drum_snare_hard,
        "co" => :drum_cymbal_open,
        "cc" => :drum_cymbal_closed,
        "et" => :elec_tick,
        "a1" => :forge_a1,
        "ab1" => :forge_ab1,
        "b1" => :forge_b1,
        "bb1" => :forge_bb1,
        "c2" => :forge_c2,
        "cs2" => :forge_cs2,
        "d2" => :forge_d2,
        "e1" => :forge_e1,
        "e2" => :forge_e2,
        "eb2" => :forge_eb2,
        "f1" => :forge_f1,
        "fs1" => :forge_fs1,
        "g1" => :forge_g1}

define :play_anvil_list do |list,steps,index|
  with_bpm_mul(steps) do
    steps.times do
      play_data_structure list[:content][index]
      index = index + 1
    end
  end
end

define :play_data_structure do |anvil|
  case anvil[:name]
  when :sym
    sample anvil[:content], sustain: 0, release: bt(anvil[:release])
    sleep 1
  when :note
    play anvil[:content], release: anvil[:release]
    sleep 1
  when :list
    play_anvil_list anvil, anvil[:content].length, 0
  when :square_bracket
    density 1/anvil[:release] do
      anvil[:content].each do |list|
        in_thread do
          play_data_structure list
        end
      end
    end
    sleep 1
  when :curly_bracket
    index = anvil[:index]
    steps = anvil[:content][0][:content].length
    density 1.0/anvil[:release] do
      anvil[:content].each do |list|
        in_thread do
          play_anvil_list list, steps, index
        end
      end
    end
    anvil[:index] = anvil[:index] + steps
    sleep 1
  when :word
    if map.has_key?(anvil[:content])
      sample map[anvil[:content]], sustain: 0, release: bt(anvil[:release])
    else
      eval anvil[:content]
    end
    sleep 1
  when :silence, :empty_list
    sleep 1
  end
end

define :ring_to_array do |ring|
  a = []
  ring.each do |e|
    a << e
  end
  a
end

define :k do
  sample :drum_heavy_kick
end

define :apply_mods do |anvil|
  case anvil[:name]
  when :list
    anvil[:content].each do |element|
      apply_mods element
    end
    anvil[:content].each_index do |list_index|
      element = anvil[:content][list_index]
      element[:mods].each_index do |mod_index|
        mod = element[:mods][mod_index]
        case mod[:name]
        when :mult
          repeats = mod[:content]
          a = ring_to_array anvil[:content]
          element[:mods].delete_at mod_index
          a.delete_at list_index
          repeats.times do
            el = element.dup
            el[:mods] = element[:mods].dup
            a.insert list_index, el
          end
          anvil[:content] = a.ring
          apply_mods anvil
        when :spread
          sprd = spread(mod[:content][:ammount],mod[:content][:per])
          a = ring_to_array anvil[:content]
          element[:mods].delete_at mod_index
          a.delete_at list_index
          sprd.each do |sprd_el|
            if sprd_el
              el = element.dup
              el[:mods] = element[:mods].dup
              a.insert list_index, el
            else
              el = { :name => :silence }
              el[:mods] = element[:mods].dup
              a.insert list_index, el
            end
          end
          anvil[:content] = a.ring
          apply_mods anvil
        when :div
          anvil[:content] = apply_divs anvil[:content]
        end
      end
    end
  when :square_bracket, :curly_bracket
    anvil[:content].map do |list|
      apply_mods list
    end
  end
end

# takes a ring, applys the div mod, return the new ring
define :apply_divs do |list|
  silent_arr = []
  a = ring_to_array list
  added_els = 0
  list.each_index do |list_i|
    silent_arr << empty_anvil
    el = list[list_i]
    el[:mods].each_index do |mod_i|
      mod = el[:mods][mod_i]
      case mod[:name]
      when :div
        div = mod[:content]
        el[:mods].delete_at mod_i
        el[:release] = el[:release]*div
        (div-1).times do
          added_els = added_els + 1
          a.insert list_i + added_els, empty_anvil
        end
      end
    end
  end
  silent_arr = {:name => :list, :content => silent_arr.ring}
  a = {:name => :list, :content => a.ring}
  return [{:name => :curly_bracket, :content => [silent_arr,a], :index => 0, :release => 1.0, :mods => []}].ring
end

define :forge do |symbol,string|
  use_bpm 30
  anvil = parser.parse(string).content
  apply_mods anvil
  with_fx :reverb, room: 0.9 do
    with_fx :distortion, distort: 0.9 do
      with_fx :flanger, feedback: 0.2 do
        live_loop symbol do
          use_synth :piano
          play_data_structure anvil
        end
      end
    end
  end
end