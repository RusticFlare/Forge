require 'treetop'
Treetop.load 'C:/Users/j_d_b/Documents/GitHub/forge/grammar/forge_grammar.tt'

parser = ForgeGrammarParser.new
empty_anvil = { :name => :silence, :mods => [] , :release => 1 }

define :play_anvil_list do |list,steps,index|
  with_bpm_mul(steps) do
    steps.times do
      play_data_structure list[:content][index]
      index = index + 1
    end
  end
end

define :play_data_structure do |anvil|
  case anvil[:name]
  when :sym
    sample anvil[:content]
    sleep 1
  when :note
    play anvil[:content], release: anvil[:release]
    sleep 1
  when :list
    play_anvil_list anvil, anvil[:content].length, 0
  when :square_bracket
    density 1/anvil[:release] do
      anvil[:content].each do |list|
        in_thread do
          play_data_structure list
        end
      end
    end
    sleep 1
  when :curly_bracket
    index = anvil[:index]
    steps = anvil[:content][0][:content].length
    density 1.0/anvil[:release] do
      anvil[:content].each do |list|
        in_thread do
          play_anvil_list list, steps, index
        end
      end
    end
    anvil[:index] = anvil[:index] + steps
    sleep 1
  when :word
    eval anvil[:content]
    sleep 1
  when :silence
    sleep 1
  end
end

define :ring_to_array do |ring|
  a = []
  ring.each do |e|
    a << e
  end
  a
end

define :k do
  sample :drum_heavy_kick
end

define :apply_mods do |anvil|
  case anvil[:name]
  when :list
    anvil[:content].each do |element|
      apply_mods element
    end
    anvil[:content].each_index do |list_index|
      element = anvil[:content][list_index]
      element[:mods].each_index do |mod_index|
        mod = element[:mods][mod_index]
        case mod[:name]
        when :mult
          repeats = mod[:content]
          a = ring_to_array anvil[:content]
          element[:mods].delete_at mod_index
          a.delete_at list_index
          repeats.times do
            el = element.dup
            el[:mods] = element[:mods].dup
            a.insert list_index, el
          end
          anvil[:content] = a.ring
          apply_mods anvil
        when :spread
          sprd = spread(mod[:content][:ammount],mod[:content][:per])
          a = ring_to_array anvil[:content]
          element[:mods].delete_at mod_index
          a.delete_at list_index
          sprd.each do |sprd_el|
            if sprd_el
              el = element.dup
              el[:mods] = element[:mods].dup
              a.insert list_index, el
            else
              el = { :name => :silence }
              el[:mods] = element[:mods].dup
              a.insert list_index, el
            end
          end
          anvil[:content] = a.ring
          apply_mods anvil
        when :div
          anvil[:content] = apply_divs anvil[:content]
        end
      end
    end
  when :square_bracket, :curly_bracket
    anvil[:content].map do |list|
      apply_mods list
    end
  end
end

# takes a ring, applys the div mod, return the new ring
define :apply_divs do |list|
  silent_arr = []
  a = ring_to_array list
  list.each_index do |list_i|
    silent_arr << empty_anvil
    el = list[list_i]
    el[:mods].each_index do |mod_i|
      mod = el[:mods][mod_i]
      case mod[:name]
      when :div
        div = mod[:content]
        el[:mods].delete_at mod_i
        el[:release] = el[:release]*div
        div.times do
          a.insert list_i + 1, empty_anvil
        end
      end
    end
  end
  silent_arr = {:name => :list, :content => silent_arr.ring}
  a = {:name => :list, :content => a.ring}
  return [{:name => :curly_bracket, :content => [silent_arr,a], :index => 0, :release => 1.0, :mods => []}].ring
end

define :forge do |string|
  anvil = parser.parse(string).content
  apply_mods anvil
  puts anvil
  live_loop :demo do
    play_data_structure anvil
  end
end

forge "[1]/3"