grammar ForgeGrammar

  rule forge
    pos_ws list pos_ws {
      def content
        { :type => :sequential , :content => elements[1].content.ring }
      end
    }
    /
    pos_ws 1..1 {
      def content
        { :type => :sequential , :content => [{ :type => :silence , :release => 1.0 , :mods => [] }].ring }
      end
    }
  end

  rule list
    expr def_ws list {
      def content
       elements[0].content + elements[2].content
      end
    }
    /
    expr 1..1 {
      def content
        elements[0].content
      end
    }
  end
  
  rule expr
    elemt mods {
      def content
        [elements[0].content.merge({ :mods => elements[1].content })]
      end
    }
    /
    elemt 1..1 {
      def content
        [elements[0].content.merge({ :mods => [] })]
      end
    }
  end
  
  rule elemt
    "[" pos_ws array pos_ws "]" {
      def content
        { :type => :parallel , :content => elements[2].content , :release => 1.0 }
      end
    }
    /
    "{" pos_ws array pos_ws "}" {
      def content
        { :type => :timed_parallel , :content => elements[2].content , :index => 0 , :release => 1.0 }
      end
    }
    /
    silence 1..1 {
      def content
        { :type => :silence , :release => 1.0 }
      end
    }
    /
    note !word {
      def content
        { :type => :note , :content => elements[0].content , :release => 1.0 }
      end
    }
    /
    word 1..1 {
      def content
        { :type => :word , :content => elements[0].content , :release => 1.0 }
      end
    }
    /
    sym 1..1 {
      def content
        { :type => :sym , :content => elements[0].content , :release => 1.0 }
      end
    }
  end
  
  rule mods
    mod mods {
      def content
        [elements[0].content] + elements[1].content
      end
    }
    /
    mod 1..1 {
      def content
        [elements[0].content]
      end
    }
  end
  
  rule mod
    '*' nat {
      def content
        { :type => :mult , :content => elements[1].content }
      end
    }
    /
    '/' nat {
      def content
        { :type => :stretch , :content => elements[1].content }
      end
    }
    /
    '-' float {
      def content
        { :type => :release , :content => elements[1].content }
      end
    }
    /
    '(' pos_ws nat comma nat pos_ws ')' {
      def content
        { :type => :spread , :content => { :ammount => elements[2].content , :per => elements[4].content } }
      end
    }
  end

	rule array
    forge comma array {
      def content
        [elements[0].content] + elements[2].content
      end
    }
    /
    forge 1..1 {
      def content
        [elements[0].content]
      end
    }
  end
  
  rule word
    [a-zA-Z0-9_]+ {
      def content
        text_value
      end
    }
  end
  
  rule nat
    [0-9]+ {
      def content
        text_value.to_i
      end
    }
  end
  
  rule float
    nat '.' nat {
      def content
        text_value.to_f
      end
    }
    /
    nat {
      def content
        text_value.to_f
      end
    }
  end
  
  rule note
    float '>' note {
      def content
        es = elements[2].content
        es[0][:slide] = 1
        [ { :note => elements[0].content } ] + es
      end
    }
    /
    float '^' note {
      def content
        es = elements[2].content
        es[0][:slide] = 0
        [ { :note => elements[0].content } ] + es
      end
    }
    /
    float 1..1 {
      def content
        [ { :note => elements[0].content } ]
      end
    }
  end
  
  rule sym
    ':' word  {
      def content
        elements[1].content.parameterize.underscore.to_sym
      end
    }
  end
  
  rule silence
    '~'
  end
  
  rule pos_ws
    ws*
  end
  
  rule def_ws
    ws+
  end
  
  rule ws
    [\s\t\r\n]
  end
  
  rule comma
    pos_ws ',' pos_ws
  end

end
